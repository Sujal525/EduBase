import{p256 as e}from"@noble/curves/p256";import{sha256 as r}from"@noble/hashes/sha256";import a from"canonicalize";import{AUTHORIZATION_PRIVATE_KEY_PREFIX as t,WALLET_API_PRIVATE_KEY_PREFIX as i}from"../constants.mjs";import{PrivyClientError as n}from"../errors.mjs";import{getWalletApiRpcPath as o,getDelegatedActionsRpcPath as d}from"../paths.mjs";const p=e=>Buffer.from(a(e)),l=(a,t)=>{let i=e.sign(r(a),t).toDERRawBytes();return Buffer.from(i)},s=r=>{let a=r.replace(t,"").replace(i,""),o=Buffer.from(a,"base64"),d=o.indexOf(Buffer.from([4,32]));if(-1===d)throw new n("Invalid wallet authorization private key");let p=o.subarray(d+2,d+34);return e.utils.normPrivateKeyToScalar(p)},y=({body:e,url:r,appId:a,idempotencyKeyHeader:t})=>({version:1,method:"POST",url:r,body:e,headers:{"privy-app-id":a,...t}}),f=e=>{if(void 0!==e.idempotencyKey)return{"privy-idempotency-key":e.idempotencyKey}},m=e=>{let r;if("walletId"in e)r=o(e.walletId);else{if(!("address"in e)||!("chainType"in e))throw new n("Invalid RPC payload. Must include `address` and `chainType` or `walletId`.");r=d()}return r},u=e=>{if("walletId"in e)return{wallet_id:e.walletId};if("address"in e&&"chainType"in e)return{address:e.address,chain_type:e.chainType};throw new n("Invalid RPC payload. Must include `address` and `chainType` or `walletId`.")},c=async({apiBody:e,baseURL:r,path:a,appId:t,idempotencyKeyHeader:i,authorizationPrivateKey:n})=>{if("bigint"!=typeof n)return;let o=y({body:e,url:`${r}${a}`,appId:t,idempotencyKeyHeader:i}),d=p(o);return{"privy-authorization-signature":l(d,n).toString("base64")}};export{c as createAuthSignatureHeader,f as extractIdempotencyKeyHeader,u as extractWalletIdentifier,y as formatRpcBodyAsSignaturePayload,m as inferRpcPath,s as normalizeP256PrivateKeyToScalar,p as serializePayloadToBuffer,l as signWithP256};
