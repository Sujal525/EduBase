"use strict";var a=require("../errors.js"),e=require("../paths.js"),t=require("../utils-b_q_8DAC.js"),i=require("./mappers.js"),r=require("./rpc/ethereum.js"),n=require("./rpc/solana.js"),s=require("./utils.js");function o(a,e){if(!Object.prototype.hasOwnProperty.call(a,e))throw TypeError("attempted to use private field on non-instance");return a}require("node-fetch-native"),require("ts-case-convert"),require("@noble/curves/p256"),require("@noble/hashes/sha256"),require("canonicalize"),require("../constants.js");var d=0,c="__private_"+d+++"__getRequestHeaders";function h({path:a,body:e,idempotencyKey:t,method:i}){let r,n=s.extractIdempotencyKeyHeader({idempotencyKey:t}),o=s.serializePayloadToBuffer({version:1,method:i,url:`${this.api.baseURL}${a}`,body:e,headers:{"privy-app-id":this.appId,...n}});this.authorizationPrivateKey&&(r=s.signWithP256(o,this.authorizationPrivateKey));let d={...n};return void 0!==r&&(d["privy-authorization-signature"]=r.toString("base64")),d}exports.WalletApi=class{async getWallets(a={}){let{cursor:i,limit:r,chainType:n}=a,{data:s}=await this.api.get(e.getWalletApiSearchPath()+t.getQueryParamsString({cursor:i,limit:r,chain_type:n}));return{nextCursor:s.next_cursor??void 0,data:s.data.map((a=>({id:a.id,address:a.address,chainType:a.chain_type,policyIds:a.policy_ids,createdAt:new Date(a.created_at)})))}}async getWallet({id:a}){let{data:t}=await this.api.get(e.getWalletApiGetPath(a));return{id:t.id,chainType:t.chain_type,address:t.address,policyIds:t.policy_ids,createdAt:new Date(t.created_at)}}async getPolicy({id:a}){let{data:t}=await this.api.get(e.getPolicyPath(a));return i.convertPolicyResonseToPolicy(t)}async createPolicy(a){let t=e.createPolicyPath(),r=i.convertPolicyCreateRequestToPolicy(a),{data:n}=await this.api.post(t,r,{headers:o(this,c)[c]({path:t,body:r,method:"POST"})});return i.convertPolicyResonseToPolicy(n)}async updatePolicy(a){let t=e.updatePolicyPath(a.id),r={name:a.name,rules:a.rules?i.convertPolicyCreateRuleToPolicyRule(a.rules):void 0},{data:n}=await this.api.patch(t,r,{headers:o(this,c)[c]({path:t,body:r,method:"PATCH"})});return i.convertPolicyResonseToPolicy(n)}async deletePolicy(a){let t=e.deletePolicyPath(a.id),i={};await this.api.delete(t,i,{headers:o(this,c)[c]({path:t,body:i,method:"DELETE"})})}async getTransaction({id:a}){let{data:t}=await this.api.get(e.getTransactionGetPath(a));return{id:t.id,walletId:t.wallet_id,caip2:t.caip2,transactionHash:t.transaction_hash,status:t.status}}async create(a){return await this.createWallet(a)}async createWallet(a){let t,{chainType:i,authorizationKeyIds:r,authorizationThreshold:n}=a,o={};"ownerId"in a&&a.ownerId?o={owner_id:a.ownerId}:"owner"in a&&a.owner&&(o={owner:{public_key:a.owner.publicKey}});let d={};"authorizationKeyIds"in a||"authorizationThreshold"in a?d={authorization_key_ids:r,authorization_threshold:n}:"additionalSigners"in a&&a.additionalSigners&&(d={additional_signers:a.additionalSigners.map((a=>({signer_id:a.signerId})))});let c={chain_type:i,...o,...d},h=s.extractIdempotencyKeyHeader(a),p=s.serializePayloadToBuffer(s.formatRpcBodyAsSignaturePayload({body:c,url:`${this.api.baseURL}${e.getWalletApiCreatePath()}`,appId:this.appId,idempotencyKeyHeader:h}));this.authorizationPrivateKey&&(t=s.signWithP256(p,this.authorizationPrivateKey));let l=void 0!==t?{"privy-authorization-signature":t.toString("base64")}:void 0,{data:y}=await this.api.post(e.getWalletApiCreatePath(),c,{headers:{...l,...h}});return{id:y.id,address:y.address,chainType:y.chain_type,policyIds:y.policy_ids,createdAt:new Date(y.created_at)}}async rpc(t){let i,r;if("walletId"in t)i=e.getWalletApiRpcPath(t.walletId);else{if(!("address"in t)||!("chainType"in t))throw new a.PrivyClientError("Invalid RPC payload. Must include `address` and `chainType` or `walletId`.");i=e.getDelegatedActionsRpcPath()}let n=function(a){let{method:e,params:t}=a,i="address"in a?{address:a.address,chain_type:a.chainType}:{wallet_id:a.walletId};switch(e){case"signTransaction":return{...i,method:e,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"signMessage":{let a=Buffer.from(t.message).toString("base64");return{...i,method:e,params:{message:a,encoding:"base64"}}}case"signAndSendTransaction":return{...i,method:e,caip2:a.caip2,params:{transaction:Buffer.from(t.transaction.serialize({verifySignatures:!1})).toString("base64"),encoding:"base64"}};case"eth_signTransaction":return{...i,method:e,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};case"personal_sign":let r;return r=t.message instanceof Uint8Array?{message:Buffer.from(t.message).toString("hex"),encoding:"hex"}:t.message.startsWith("0x")?{message:t.message,encoding:"hex"}:{message:t.message,encoding:"utf-8"},{...i,method:e,params:r};case"eth_signTypedData_v4":return{...i,method:e,params:{typed_data:{domain:t.typedData.domain,types:t.typedData.types,message:t.typedData.message,primary_type:t.typedData.primaryType}}};case"eth_sendTransaction":return{...i,method:e,caip2:a.caip2,params:{transaction:{from:t.transaction.from,to:t.transaction.to,nonce:t.transaction.nonce,chain_id:t.transaction.chainId,data:t.transaction.data,value:t.transaction.value,type:t.transaction.type,gas_limit:t.transaction.gasLimit,gas_price:t.transaction.gasPrice,max_fee_per_gas:t.transaction.maxFeePerGas,max_priority_fee_per_gas:t.transaction.maxPriorityFeePerGas}}};default:throw Error(`Unsupported method: ${e}`)}}(t),o=s.extractIdempotencyKeyHeader(t),d=s.serializePayloadToBuffer(s.formatRpcBodyAsSignaturePayload({body:n,url:`${this.api.baseURL}${i}`,appId:this.appId,idempotencyKeyHeader:o}));this.authorizationPrivateKey&&(r=s.signWithP256(d,this.authorizationPrivateKey));let c=void 0!==r?{"privy-authorization-signature":r.toString("base64")}:void 0,{data:h}=await this.api.post(i,n,{headers:{...c,...o}});return await async function(a,e){switch(e.method){case"signMessage":return{method:e.method,data:{signature:Buffer.from(e.data.signature,"base64")}};case"signTransaction":let t,i=a.params.transaction,r=Buffer.from(e.data.signed_transaction,"base64"),{Transaction:n,VersionedTransaction:s}=await import("@solana/web3.js");return t="version"in i?s.deserialize(r):n.from(r),{method:e.method,data:{signedTransaction:t}};case"signAndSendTransaction":if(e.data)return{method:e.method,data:{transactionId:e.data.transaction_id,hash:e.data.hash,caip2:e.data.caip2}};if(e.error)return{method:e.method,error:{code:e.error.code,message:e.error.message}};throw Error("Unexpected API response to signAndSendTransaction");case"eth_signTransaction":return{method:e.method,data:{signedTransaction:e.data.signed_transaction,encoding:e.data.encoding}};case"eth_sendTransaction":if(e.data)return{method:e.method,data:{transactionId:e.data.transaction_id,hash:e.data.hash,caip2:e.data.caip2}};if(e.error)return{method:e.method,error:{code:e.error.code,message:e.error.message}};throw Error("Unexpected API response to eth_sendTransaction");case"personal_sign":case"eth_signTypedData_v4":return{method:e.method,data:{signature:e.data.signature,encoding:e.data.encoding}};default:throw Error("Unsupported method")}}(t,h)}constructor({appId:a,api:e,authorizationPrivateKey:t}){Object.defineProperty(this,c,{value:h}),this.authorizationPrivateKey=null,this.api=e,t&&(this.authorizationPrivateKey=s.normalizeP256PrivateKeyToScalar(t)),this.appId=a,this.ethereum=new r.EthereumRpcApi({appId:a,api:e,authorizationPrivateKey:this.authorizationPrivateKey}),this.solana=new n.SolanaRpcApi({appId:a,api:e,authorizationPrivateKey:this.authorizationPrivateKey})}};
